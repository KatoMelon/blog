<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>互联网协议 on KatMelon's Blog</title><link>https://katomelon.github.io/blog/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/</link><description>Recent content in 互联网协议 on KatMelon's Blog</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Thu, 08 Aug 2024 00:00:00 +0000</lastBuildDate><atom:link href="https://katomelon.github.io/blog/tags/%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE/index.xml" rel="self" type="application/rss+xml"/><item><title>互联网协议 - Week3概念整理</title><link>https://katomelon.github.io/blog/p/ipn-w3/</link><pubDate>Thu, 08 Aug 2024 00:00:00 +0000</pubDate><guid>https://katomelon.github.io/blog/p/ipn-w3/</guid><description>&lt;h2 id="nat-网络地址转换">NAT 网络地址转换
&lt;/h2>&lt;p>NAT = Network Address Translation
背景：ipv4 的可分配地址少，不够用了，且分配不公平。&lt;/p>
&lt;p>NAT 的做法：把内部网（家庭网）流出的数据报由同一个 NAT IP 地址发出，将不同的内部 IP 映射到不同的端口号上。对内部网，数据报视作由该 NAT 路由发出。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602163120.png"
loading="lazy"
>
这样一来本地网只需要一个 IP 地址，但对外部网来说：&lt;/p>
&lt;ul>
&lt;li>IP 地址可不需要通过 ISP 提供&lt;/li>
&lt;li>内部设备或地址可随意更换，无需通知外部网&lt;/li>
&lt;li>可在不调整内部网地址的情况下更换 ISP&lt;/li>
&lt;li>&lt;strong>（重要）内部网设备不可从外部显式访问&lt;/strong>&lt;/li>
&lt;/ul>
&lt;p>NAT 的实现：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>对向外流出的数据报：&lt;/strong> 将数据报的来源 IP 地址替换为 NAT 路由的地址（和映射分配的端口）再发给外网。&lt;/li>
&lt;li>外部服务器会收到这条请求，其回复的目标 IP 地址会是 NAT 路由的地址和端口。&lt;/li>
&lt;li>&lt;strong>对向内流入的数据报：&lt;/strong> 将回复中的目标 IP 地址和端口替换为内部网实际主机的 IP 地址和端口&lt;/li>
&lt;/ol>
&lt;p>端口号是 16 位的，这说明一次 NAT 可以支持最多六万个同时连接。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602163652.png"
loading="lazy"
>
NAT 的争议问题：&lt;/p>
&lt;ol>
&lt;li>路由器应当只处理第三层（即网络层）的问题。注意，&lt;strong>事实上一个 NAT box 应当被视作网络层成员&lt;/strong>，因为虽然看起来是端口 - 端口通信，但还是第三层的。&lt;/li>
&lt;li>地址短缺问题应当通过 ipv6 解决&lt;/li>
&lt;li>端到端复杂性违例：使用 NAT 不符合原先网络层的所有设计，这使得应用开发者在开发应用时必须考虑到有 NAT 存在的情况，不能大规模使用 IP 确认的 P2P 等等。&lt;/li>
&lt;li>&lt;strong>客户端无法访问到 NAT 之后的服务器。&lt;/strong>&lt;/li>
&lt;/ol>
&lt;h2 id="ipv6">IPv6
&lt;/h2>&lt;p>提案动机：使用 32 位 IP 地址，能给宇宙里的每一颗沙子都分一个地址用。
一些额外的东西：修改了数据头的格式，可加速处理与转发，改善服务质量（QoS，Quality of Service）。&lt;/p>
&lt;h3 id="ipv6-数据头">IPv6 数据头
&lt;/h3>&lt;p>为固定 40 字节大小的头，不允许分片。&lt;/p>
&lt;ul>
&lt;li>优先级：指定 flow 中数据报的优先级&lt;/li>
&lt;li>flow 标签：指定数据报是否在同一个 flow 中&lt;/li>
&lt;li>next header：指定上层的数据协议&lt;/li>
&lt;/ul>
&lt;p>感觉这东西考的概率不大。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602170158.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="ipv6-的其他变化">IPv6 的其他变化
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>移除了数据报中的校验和部分&lt;/strong>：IPv6 认为在链路层和传输层（如 TCP 和 UDP）已经有足够的错误检测机制，所以可以省略 IP 层的校验和，从而减少每个中继节点（hop）处理数据包的时间，提高转发效率。&lt;/li>
&lt;li>在 IPv4 中，选项（options）是 IP 头部的一部分，可以使头部变得很长，影响数据包的处理速度。而在 IPv6 中，选项被允许存在，但它们不再是头部的一部分，而是通过一个称为“Next Header”（下一个头部）的字段来指示。这意味着选项信息被放在扩展头部中，使基本的 IPv6 头部保持固定长度（40 字节），从而简化了处理。&lt;/li>
&lt;li>支持 ICMPv6 &amp;mdash; ICMP（Internet Control Message Protocol）是用于网络设备间传递控制信息的协议。在 IPv6 中，引入了一个新的版本 ICMPv6。ICMPv6 不仅保留了原有的 ICMP 功能，还增加了一些新的消息类型，比如“Packet Too Big”消息，用于通知发送方数据包太大，需要分片。ICMPv6 还包括多播组管理功能，用于管理多播组的成员关系。&lt;/li>
&lt;/ul>
&lt;p>了解即可。&lt;/p>
&lt;h3 id="从-ipv4-迁移--向下兼容">从 IPv4 迁移 &amp;amp; 向下兼容
&lt;/h3>&lt;p>没有办法让所有路由器一夜之间从 IPv4 迁移到 IPv6，因此需要能够在有 IPv4 的路由器的网络中传输 IPv6 数据包。
做法：&lt;strong>隧道技术（tunneling）&lt;/strong>,将整个 IPv6 数据报封装到 IPv4 的负载 payload 中进行传输
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602171430.png"
loading="lazy"
>
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602171505.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="软件定义网络-sdn">软件定义网络 SDN
&lt;/h2>&lt;p>传统网络：&lt;/p>
&lt;ul>
&lt;li>数据平面通过转发表 forwaring table 根据最长前缀匹配原则进行数据包转发。&lt;/li>
&lt;li>控制平面会为每个路由器计算出转发表&lt;/li>
&lt;li>转发表只能根据 IP 地址来决定怎样转发数据包&lt;/li>
&lt;/ul>
&lt;p>软件定义网络：更加灵活&lt;/p>
&lt;ul>
&lt;li>可使用编程语言 Java、Python 等编写自己的控制算法&lt;/li>
&lt;li>可根据数据包头的任意部分进行转发。&lt;/li>
&lt;/ul>
&lt;p>SDN 数据平面：&lt;/p>
&lt;ul>
&lt;li>由控制平面下发一系列“match-action”规则，可对数据包做很多操作（转发、修改数据等等）&lt;/li>
&lt;li>更加灵活（例如，可单独路由视频数据包，将隐私数据包单独路由，丢弃可以数据包等）&lt;/li>
&lt;/ul>
&lt;p>SDN 控制平面：&lt;/p>
&lt;ul>
&lt;li>单个中心化的控制器（不是分布式系统）&lt;/li>
&lt;li>可编程，而非固定的。可以对控制器进行编程。&lt;/li>
&lt;li>可以创造自己的路由算法然后直接在网络上测试，不用先花大量美金去造个硬件路由器。&lt;/li>
&lt;/ul>
&lt;p>每个路由器会带有一张流向表 flow table，由路由控制器计算并分发出去。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602175958.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="openflow">OpenFlow
&lt;/h3>&lt;p>OpenFlow 是一种 SDN 协议。构成如下：
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602180128.png"
loading="lazy"
>
匹配规则 + 动作。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602180218.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="路由协议">路由协议
&lt;/h2>&lt;p>找出从发送主机到接收主机间，经过的路由器的“好的”路线。&lt;/p>
&lt;ul>
&lt;li>路线：数据包从给定的初始源主机到给定的最终目的主机所经过的路由器序列&lt;/li>
&lt;li>“好”：低成本，速度快，低拥塞。&lt;/li>
&lt;/ul>
&lt;h3 id="路由算法分类">路由算法分类
&lt;/h3>&lt;p>信息是否全局？
全局 - 所有路由器都能得到网络全局的拓扑情况和信息等——&lt;strong>link state 算法&lt;/strong>
去中心化 - 路由器知道与自己相连的邻居，到邻居间的连接成本——&lt;strong>distance vector 算法&lt;/strong>&lt;/p>
&lt;p>网络结构动态还是静态？
静态：路由随时间变化基本不变化
动态：路由会快速变化，定期更新，响应连接成本变化等。&lt;/p>
&lt;h3 id="link-state-路由算法">Link-state 路由算法
&lt;/h3>&lt;p>使用迪杰斯特拉算法作最短路计算。&lt;/p>
&lt;p>这个是个很成块的大题，此处略，见串讲的讲解：
【互联网协议串讲 - 北邮国际学院 (全 3p)】 【精准空降到 1:26:47】 &lt;a class="link" href="https://www.bilibili.com/video/BV1qy4y177LM/?p=2&amp;amp;share_source=copy_web&amp;amp;vd_source=dac6d447bab3520339763cd9fb9b0afa&amp;amp;t=5207" target="_blank" rel="noopener"
>https://www.bilibili.com/video/BV1qy4y177LM/?p=2&amp;share_source=copy_web&amp;vd_source=dac6d447bab3520339763cd9fb9b0afa&amp;t=5207&lt;/a>&lt;/p>
&lt;h3 id="distance-vector-路由算法">Distance vector 路由算法
&lt;/h3>&lt;p>使用 Bellman-Fold 算法。&lt;/p>
&lt;p>【互联网协议串讲 - 北邮国际学院 (全 3p)】 【精准空降到 1:40:02】 &lt;a class="link" href="https://www.bilibili.com/video/BV1qy4y177LM/?p=2&amp;amp;share_source=copy_web&amp;amp;vd_source=dac6d447bab3520339763cd9fb9b0afa&amp;amp;t=6002" target="_blank" rel="noopener"
>https://www.bilibili.com/video/BV1qy4y177LM/?p=2&amp;share_source=copy_web&amp;vd_source=dac6d447bab3520339763cd9fb9b0afa&amp;t=6002&lt;/a>&lt;/p>
&lt;h2 id="自治系统as与路由">自治系统（AS）与路由
&lt;/h2>&lt;p>AS = autonomous systems&lt;/p>
&lt;p>上述的路由算法都太理想化了：认为所有路由器完全相同，所有网络均扁平，这和实际不符。
真实的网络系统：&lt;/p>
&lt;ul>
&lt;li>有百万个主机和路由目的地等，你无法在路由表中存储所有目标。&lt;/li>
&lt;li>只采用 distance vector 方法进行路由表交换会导致大量网络拥塞。&lt;/li>
&lt;li>互联网是网中之网，每个网络管理员可能希望控制自己网络中的路由规则。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>intra-AS 路由（AS 内路由）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在同一个 AS 网络内进行路由&lt;/li>
&lt;li>同个 AS 内的所有路由器必须运行相同协议&lt;/li>
&lt;li>不同 AS 内的路由可以运行不同协议&lt;/li>
&lt;li>存在网关路由：在自己 AS 的边缘，和其他 AS 的路由相连接。&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>inter-AS 路由（AS 间路由）&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>在不同 AS 间路由&lt;/li>
&lt;li>网关路由器同时做内路由和外路由&lt;/li>
&lt;/ul>
&lt;p>考虑 AS 的路由情况，路由表/转发表是有 AS 内和 AS 间的路由算法共同配置决定的。AS 内路由决定 AS 内的路由情况，二者共同作用决定外部目标的路由情况。&lt;/p>
&lt;h3 id="intra-as-路由as-内路由">intra-AS 路由（AS 内路由）
&lt;/h3>&lt;p>IGP = interior gateway protocols 内部网关协议
常见的内部路由协议：&lt;/p>
&lt;ul>
&lt;li>RIP: Routing Information Protocol&lt;/li>
&lt;li>&lt;strong>咱们讲的是这个 -&amp;gt; OSPF: Open Shortest Path First (IS-IS protocol essentially same as OSPF)&lt;/strong>&lt;/li>
&lt;li>IGRP: Interior Gateway Routing Protocol (Cisco proprietary for decades, until 2016)&lt;/li>
&lt;/ul>
&lt;p>OSPF 协议采用 link state 算法：网络间会分发 link state 数据包，得到每个节点的拓扑结构，然后基于迪杰斯特拉算法进行计算路由。
路由器会向整个 AS 内的所有路由器广播（flood）通告 OSPF 数据包，这一步是直接通过 IP 协议而非 TCP 或 UDP。&lt;/p>
&lt;p>IS-IS 路由协议和 OSPF 基本一样。&lt;/p>
&lt;p>高级特性：&lt;/p>
&lt;ul>
&lt;li>安全性：所有 OSPF 消息均需认证&lt;/li>
&lt;li>允许多个相同成本的路径（RIP 不支持）&lt;/li>
&lt;li>支持不同 ToS 的链路成本指标&lt;/li>
&lt;li>集成的单播和多播支持。MOSPF（多播 OSPF）利用与标准 OSPF 相同的拓扑数据库来计算多播路由信息。&lt;/li>
&lt;li>在大型网络中，OSPF 可以采用分层结构，通过划分区域来提高网络的可扩展性和管理效率。&lt;/li>
&lt;/ul>
&lt;h3 id="inter-as-路由as-间路由">inter-AS 路由（AS 间路由）
&lt;/h3>&lt;p>任务：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>需要知道哪个目的地能够到达 AS2，哪能到达 AS3&lt;/p>
&lt;/li>
&lt;li>
&lt;p>要把这个信息告诉当前 AS1 内的所有路由器
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602192903.png"
loading="lazy"
>
BGP = Border Gateway Protocol&lt;/p>
&lt;/li>
&lt;li>
&lt;p>eBGP：&lt;strong>从相邻的 AS 获取子网可达性信息&lt;/strong>。eBGP（外部 BGP）用于在不同的自治系统（AS）之间交换路由信息。通过 eBGP，AS 可以从相邻的 AS 获取到哪些子网是可达的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>iBGP： &lt;strong>将可达性信息传播给所有 AS 内部的路由器&lt;/strong>。iBGP（内部 BGP）用于在同一个自治系统内部传播路由信息。这样，AS 内部的所有路由器都可以知道哪些子网是可达的。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>BGP 不仅仅是传递路由信息，它还要根据这些信息和预先设定的策略来选择最佳路由。所谓“好”路由通常指的是更优的路径，这可以基于多种因素，例如路径长度、路由策略、带宽等。
通过 BGP，某个子网可以向整个互联网公告它的存在。这意味着其他 AS 可以通过 BGP 了解该子网的可达性，并据此进行路由选择。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w3/assets/Pasted%20image%2020240602200832.png"
loading="lazy"
>&lt;/p></description></item><item><title>互联网协议 - 课程概要 &amp; Week1概念整理</title><link>https://katomelon.github.io/blog/p/ipn-w1/</link><pubDate>Thu, 08 Aug 2024 00:00:00 +0000</pubDate><guid>https://katomelon.github.io/blog/p/ipn-w1/</guid><description>&lt;p>&lt;img src="https://badges.toozhao.com/badges/01HJ3GGQ6MR66VM70BVZS4SSVX/green.svg"
loading="lazy"
alt="Page Views Count"
>&lt;/p>
&lt;h2 id="考核">考核
&lt;/h2>&lt;p>考核形式和绝大多数英方课形式类似，coursework + final exam，考试占 75%，平时占 25%。平时成绩由一次小组视频作业、两次小测，一次 Lab 组成。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>考核项&lt;/th>
&lt;th>类型&lt;/th>
&lt;th>占比&lt;/th>
&lt;th>说明&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>期末考试&lt;/td>
&lt;td>Final&lt;/td>
&lt;td>75%&lt;/td>
&lt;td>( ˇωˇ)&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>课程小测 *2&lt;/td>
&lt;td>Coursework&lt;/td>
&lt;td>10%&lt;/td>
&lt;td>第一次小测时间 March 14th，后面的待通知，具体时间地点考试内容详见 QMPlus 和相关邮件，闭卷考试。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>小组视频&lt;/td>
&lt;td>Coursework&lt;br>&lt;/td>
&lt;td>5%&lt;/td>
&lt;td>介绍一个国内的互联网应用，包括基本描述，网络架构，需求，影响和未来发展。最长五分钟。&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>Lab&lt;/td>
&lt;td>Coursework&lt;br>&lt;/td>
&lt;td>10%&lt;/td>
&lt;td>&lt;a class="link" href="https://icebound.cc/2019/01/25/is-courses.html" target="_blank" rel="noopener"
>icebound&lt;/a>：LAB 是上机实际操作 packet tracer 这个软件。在 LAB 开始前一周会教大家使用这个软件。LAB 当天，就像考试一样大家进机房，之后会发一个考试题，上面有本次 LAB 的要求。做完之后会有助教来检查，并且问你两个互联网协议的问题。助教会根据你的回答还有 LAB 的完成情况给分。&lt;br/>（2024.08.08更新：今年lab没有考试环节，是要求你做完实验之后，填写一个实验手册，给你搭好的网络拓扑截图、运行一些指令等等，然后将你的工程文件和手册全部提交到qmplus上）&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>课程排课共四周：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>周数&lt;/th>
&lt;th>内容&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>第一周&lt;/td>
&lt;td>课程基本介绍，传输层 Part1，&lt;strong>小组视频作业&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>第二周&lt;/td>
&lt;td>传输层 Part2，网络层 Part1，&lt;strong>第一次小测&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>第三周&lt;/td>
&lt;td>网络层 Part2，数据链路层 Part1，Lab 的 Tutorial &lt;strong>（随后 Lab）&lt;/strong>&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>第四周&lt;/td>
&lt;td>数据链路层 Part2，网络管理与安全，&lt;strong>第二次小测&lt;/strong>&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>本资料的术语未经严格校对，仅供参考。&lt;/p>
&lt;h2 id="11-何为互联网">1.1 何为互联网
&lt;/h2>&lt;p>本部分定义/介绍了课程中需要使用的一些基本概念：互联网的组成、元素，何为协议，网络边缘与网络核心，一些基础术语（比特、字节、网络数据），何为物理媒介、何为带宽等等。&lt;/p>
&lt;h3 id="互联网的组成">互联网的组成
&lt;/h3>&lt;h4 id="从构成的角度">从构成的角度
&lt;/h4>&lt;p>互联网是连接计算机与计算机的网络（这门课的另外一个名字叫计算机网络），即数以百万计的相连计算机构成了互联网。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>主机 Host&lt;/strong>：即终端系统，运行着网络应用程序。&lt;/li>
&lt;li>&lt;strong>通信链路 Communication links&lt;/strong>：即光纤 fiber、铜线 copper、无线电 radio、卫星 satellite 等用于传输信息的链路设备。&lt;/li>
&lt;li>&lt;strong>带宽 Bandwidth&lt;/strong>：数据链路的传输速率。&lt;/li>
&lt;li>&lt;strong>数据包交换器 Packet switches&lt;/strong>：用来转发 Forward 数据包，可以是路由器 Router 或交换机 switches。&lt;/li>
&lt;/ul>
&lt;p>此外：&lt;/p>
&lt;ul>
&lt;li>互联网是“网中之网”，连接起多个&lt;strong>互联网服务提供商 ISP, Internet Service Provider&lt;/strong>，能够互相通信。&lt;/li>
&lt;li>数据的正常通信需要依靠事先约定好的&lt;strong>协议 Protocol&lt;/strong> 才能进行。例如 TCP、IP、HTTP、802.11(WiFi 标准) 等等。&lt;/li>
&lt;li>有多种多样的&lt;strong>互联网标准 Internet Standards&lt;/strong>，如 RFC，IETF 等等。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240308142457.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="从服务的角度">从服务的角度
&lt;/h4>&lt;ul>
&lt;li>向应用提供服务的基础设施
Web, VoIP (Voice over IP), email, games, e-commerce, social nets 等。&lt;/li>
&lt;li>向应用提供编程接口的基础设施
允许发送和接收应用程序“连接”到互联网的钩子，提供服务选项，类似于邮政&lt;/li>
&lt;/ul>
&lt;h3 id="何为协议-protocol">何为协议 Protocol
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原&lt;/th>
&lt;th>protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>译&lt;/td>
&lt;td>协议定义了网络实体之间发送和接收消息的格式、顺序，以及消息发送、接收时所采取的动作&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240308151018.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="12-网络边缘">1.2 网络边缘
&lt;/h2>&lt;h3 id="网络边缘与网络核心">网络边缘与网络核心
&lt;/h3>&lt;p>想象互相连接无数设备的互联网是一张大网，“网络边缘 Network Edge”即网络的终端设备（服务器 Server 与客户端 Client），通过“接入网 Access Network”与网络的其他部分相连，通过“核心网 Network Core”连接网中之网，互相通信。&lt;/p>
&lt;ul>
&lt;li>&lt;strong>网络边缘 Network Edge&lt;/strong>：是用户和计算机与网络相连的部分，即主机 Hosts（服务器 + 客户端），服务器通常在数据中心里。&lt;/li>
&lt;li>&lt;strong>接入网 Access Network、物理媒介 Physical Media&lt;/strong>：是将网络边缘与网络的其他部分相连的部分。例如家庭网，办公网，移动网络等等。&lt;/li>
&lt;li>&lt;strong>核心网 Network Core&lt;/strong>：网络的“中心”部分，即互相连接的路由器，网中之网。&lt;/li>
&lt;/ul>
&lt;h3 id="比特-bit-和字节-byte">比特 Bit 和字节 Byte
&lt;/h3>&lt;ul>
&lt;li>一个比特 bit 即一个二进制数字 Binary Digit（0 或 1）&lt;/li>
&lt;li>一个字节 Byte 为一组共 8 个比特，可视为 0-255（或 -128 到 127）的数字，或两位十六进制 Hexadecimal 数字（A0, FF, 10 这样的）&lt;/li>
&lt;/ul>
&lt;p>数据量（KB MB GB）通常以字节为单位，传输速度（Kb/s Mb/s）通常以比特作单位。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240308161151.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="网络数据包-packet">网络数据包 Packet
&lt;/h3>&lt;p>&lt;em>数据包（packet），另译作报文/数据报文&lt;/em>
很大的数据难以传输，将数据切分成小单元（即数据包 Packets）会很有用。
数据包传输起来相对更快，可以检查传输错误，如果发现错误，可以重新传输。&lt;/p>
&lt;h4 id="数据包传输过程">数据包传输过程
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>获取应用消息&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将数据切分为长度为 L 个比特的数据包&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将数据包以&lt;strong>传输速率 transmission rate&lt;/strong>（表示为 R）传输进接入网&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;strong>link transmission rate&lt;/strong>, aka &lt;strong>link capacity&lt;/strong>, aka &lt;strong>link bandwidth&lt;/strong>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>链路传输速率，又名链路容量，又名链路带宽&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="13-核心网-network-core">1.3 核心网 Network Core
&lt;/h2>&lt;h4 id="数据包的传输延迟-delay">数据包的传输延迟 Delay
&lt;/h4>&lt;p>例：1500B 的数据以 1Mb/s 的速率传输，（传输延迟）耗时多少？
Time = 1500×8 (bits) / 1000000 (bits/s) = 0.012s = 12ms
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240308163049.png"
loading="lazy"
>
核心网是内部相连的多个路由器构成的网格。在进行数据包交换时，主机会将应用层数据分解为数据包。从来源到目的地的链路上，将数据包由一个路由器上转发到另一个中。每个数据包都以全容量传输。数据包必须&lt;strong>完整到达&lt;/strong>路由器后才可进行下一步的传输。&lt;/p>
&lt;p>例：如图所示，传输&lt;strong>1500B&lt;/strong>大小的数据包有多长时间的（传输）延迟？
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240308203537.png"
loading="lazy"
>
Time = 1500×8 (bits) / 1000000 (bits/s) + 1500×8 (bits) / 2000000 (bits/s) = 18ms&lt;/p>
&lt;h4 id="队列-queue-与丢包-loss">队列 Queue 与丢包 Loss
&lt;/h4>&lt;p>如果到达的数据包超过了链路的传输速率：&lt;/p>
&lt;ul>
&lt;li>数据包将&lt;strong>进入排队&lt;/strong>，等待传输。&lt;/li>
&lt;li>如果缓冲区 Buffer&lt;strong>已满&lt;/strong>，数据包将会&lt;strong>丢失&lt;/strong>。&lt;/li>
&lt;/ul>
&lt;h3 id="核心网的两大功能">核心网的两大功能
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>路由 Routing&lt;/strong>：决定数据包从来源到目的地的&lt;strong>路线 Route&lt;/strong>。&lt;/li>
&lt;li>&lt;strong>转发 Forwarding&lt;/strong>：将数据包从路由器的输入&lt;strong>移动到&lt;/strong>合适的路由器出口。&lt;/li>
&lt;/ul>
&lt;h3 id="互联网的结构">互联网的结构
&lt;/h3>&lt;ol>
&lt;li>每个使用者不可能直接连接（需要的连接数太多），所以每个使用者先连接到互联网服务提供商。&lt;/li>
&lt;li>互联网服务提供是一项可行的业务，所以会有多家 ISP 进行竞争。&lt;/li>
&lt;li>多个 ISP 间也需要互相连接（通过 Internet eXchange Provider），不然中国电信的用户就没法给中国移动的用户发微信了。&lt;/li>
&lt;li>可能出现区域网络用来连接接入网到 ISP。&lt;/li>
&lt;li>谷歌等大型企业则通过内容提供网络向用户提供服务。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240310152100.png"
loading="lazy"
>
一种结构：谷歌等大公司会直接将其数据中心连接到互联网，通常会绕过一级 ISP 和区域性 ISP。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240310152711.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="14-延迟-delay-丢包-loss-吞吐量-throughput">1.4 延迟 Delay 丢包 Loss 吞吐量 Throughput
&lt;/h2>&lt;p>回顾 - 丢包和延迟是怎么产生的：&lt;a class="link" href="%e4%ba%92%e8%81%94%e7%bd%91%e5%8d%8f%e8%ae%ae/%e4%ba%92%e8%81%94%e7%bd%91%e5%8d%8f%e8%ae%ae%20Part%20A.md#%e9%98%9f%e5%88%97Queue%e4%b8%8e%e4%b8%a2%e5%8c%85Loss" >队列Queue与丢包Loss&lt;/a>&lt;/p>
&lt;h3 id="延迟的组成">延迟的组成
&lt;/h3>&lt;p>d_total = d_proc + d_queue + d_trans + d_prop
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240310153709.png"
loading="lazy"
>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>d_proc&lt;/strong>：该节点的&lt;strong>处理延迟&lt;/strong>。用于校验比特错误，决定输出链路。通常花费小于毫秒的时间。&lt;/li>
&lt;li>&lt;strong>d_queue&lt;/strong>：在输出链路上&lt;strong>排队等待传输的延迟&lt;/strong>，取决于路由器的拥塞程度。&lt;/li>
&lt;li>&lt;strong>d_trans&lt;/strong>：&lt;strong>传输延迟&lt;/strong>。&lt;a class="link" href="%e4%ba%92%e8%81%94%e7%bd%91%e5%8d%8f%e8%ae%ae/%e4%ba%92%e8%81%94%e7%bd%91%e5%8d%8f%e8%ae%ae%20Part%20A.md#%e6%95%b0%e6%8d%ae%e5%8c%85%e7%9a%84%e4%bc%a0%e8%be%93%e5%bb%b6%e8%bf%9fDelay" >数据包的传输延迟Delay&lt;/a> = L/R。可理解为路由器将比特写入到输出端的耗时。&lt;/li>
&lt;li>&lt;strong>d_prop&lt;/strong>：&lt;strong>传播 Propagate 延迟&lt;/strong>。为数据在介质中传播的时间，= 物理链路长度 d/传播速度 s
&lt;strong>传输延迟和传播延迟是两个不同的概念。&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="丢包-loss">丢包 Loss
&lt;/h3>&lt;p>队列（或称缓冲区 Buffer）容量有限，队列满后到达的数据包将丢失。
丢失的数据包可能由上个节点重传，可能由数据发送源重传，也可能就不传了。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240310154944.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="吞吐量-throughput">吞吐量 Throughput
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原&lt;/th>
&lt;th>throughput: rate (bits/time unit) at which bits transferred between sender/receiver&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>译&lt;/td>
&lt;td>吞吐量：发送端/接收端之间传输比特的速率 (比特/时间单位)&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>分瞬时值和某段时间的平均值。
&lt;strong>瓶颈链路 Bottleneck Link&lt;/strong>：限制端到端吞吐量的链路。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311145352.png"
loading="lazy"
>
共用链路计算端到端吞吐量时应取平均到每条链路上的吞吐量计算瓶颈值。&lt;/p>
&lt;h2 id="15-协议层与服务模型">1.5 协议层与服务模型
&lt;/h2>&lt;h3 id="为什么需要分层">为什么需要分层
&lt;/h3>&lt;ul>
&lt;li>显式指定结构可明确复杂系统的各个部分（参考模型待下文讨论）。&lt;/li>
&lt;li>模块化简化了系统的维护和更新步骤（某部分的实现的变更对系统的其他部分透明）。&lt;/li>
&lt;/ul>
&lt;h3 id="tcpip-模型互联网模型">TCP/IP 模型（互联网模型）
&lt;/h3>&lt;p>TCP = 传输控制协议 Transmission Control Protocol
IP = 互联网协议 Internet Protocol
&lt;strong>自顶向下：应用层、传输层、网络层、链路层、物理层。&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>应用层&lt;/strong>：支持网络应用程序（FTP、SMTP、HTTP 等）&lt;/li>
&lt;li>&lt;strong>传输层&lt;/strong>：进程之间的数据传输（TCP、UDP）&lt;/li>
&lt;li>&lt;strong>网络层&lt;/strong>：数据报 Datagrams 从源到目的地的路由（IP、路由协议）&lt;/li>
&lt;li>&lt;strong>链路层&lt;/strong>：临近网路单元间的数据传输（以太网 Ethernet、WiFi、PPP）&lt;/li>
&lt;li>&lt;strong>物理层&lt;/strong>：即比特在线缆上的传输&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311151005.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="isoosi-参考模型">ISO/OSI 参考模型
&lt;/h3>&lt;p>ISO = 国际标准化组织 Internet Standards Office
OSI = 开放系统互连标准 Open System Interconnection
&lt;strong>相比互联网模型添加了表示层和会话层&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>&lt;strong>表示层&lt;/strong>：允许应用解释数据含义，例如加密压缩等。&lt;/li>
&lt;li>&lt;strong>会话层&lt;/strong>：提供数据同步、检查点、数据恢复交换等。
互联网模型缺少这两层，如有需要应当在&lt;strong>应用层&lt;/strong>实现。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311151240.png"
loading="lazy"
>
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311155907.png"
loading="lazy"
>&lt;/li>
&lt;/ul>
&lt;h3 id="传输模型的各层">传输模型的各层
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>第七层 - 应用层&lt;/strong>：计算机上的应用程序的数据。&lt;/li>
&lt;li>&lt;strong>第六层 - 表示层&lt;/strong>：与字符集的设定和表示有关（在 TCP/IP 和现实互联网中不存在）&lt;/li>
&lt;li>&lt;strong>第五层 - 会话层&lt;/strong>：与连接的整个生命周期有关（在 TCP/IP 和现实互联网中不存在）&lt;/li>
&lt;li>&lt;strong>第四层 - 传输层&lt;/strong>：与机器间的端到端连接有关。包含有关稳定性的信息、有关机器上的哪个程序将会发送/接受此数据的信息。&lt;/li>
&lt;li>&lt;strong>第三层 - 网络层&lt;/strong>：使得数据能够从出发的计算机到接受的计算机。带有计算机的 IP 地址，带有校验和 checksum 以检验数据是否受损。&lt;/li>
&lt;li>&lt;strong>第二层 - 数据链路层&lt;/strong>：使得数据能够到达临近（在同一本地网络下）的计算机。包含 MAC（Media Access Control）地址以区分计算机。&lt;/li>
&lt;li>&lt;strong>第一层 - 物理层&lt;/strong>：天上的无线电，地下的电缆。&lt;/li>
&lt;/ul>
&lt;h3 id="各层的设备">各层的设备
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>路由器&lt;/strong>：第三层的设备。读取第三层的地址，决定数据包将往哪个方向走。&lt;/li>
&lt;li>&lt;strong>交换机&lt;/strong>：第二层的设备。读取第二层的地址，决定哪台临近的计算机应当得到该信息。交换机通常比路由器要简单。&lt;/li>
&lt;li>&lt;strong>中继器&lt;/strong>：第一层的设备。加强信号或重构受损的信号，使得能够继续发送他。&lt;/li>
&lt;/ul>
&lt;h3 id="tcpip分层与表头">TCP/IP：分层与表头
&lt;/h3>&lt;p>TCP/IP 模型的绝大多数层都伴随一个“表头”（“表头和表尾”）
&lt;strong>表头中包含与发送的信息相分离的信息，用以说明关于此信息的一些信息。&lt;/strong>
（除物理层）每层都会附加一个 Header，例如网络层会附加一个网络地址表示该数据包将被发送到哪里，传输层会附加一个端口号表示要将该包发送给哪个程序。
下层状态会包含上层所有的包。例如第二层（链路层）中会包含来自第三层、第四层的包。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311155600.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="为什么有-isoosi-和-tcpip-两种模型">为什么有 ISO/OSI 和 TCP/IP 两种模型
&lt;/h3>&lt;p>&lt;strong>一句话说完&lt;/strong>：ISO/OSI 模型是委员会提出的，很理想化，且规划模型花费了很长时间；TCP/IP 模型是工程师提出的，目标是能上线用起来再说，在实验中对该协议进行新的修改和应用。ISO/OSI 模型提出的时候，TCP/IP 已经发展的大到不可改变的程度了。
会话层和表示层很有用，但是现在还不存在。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311161832.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="16-发展历史">1.6 发展历史
&lt;/h2>&lt;p>略，详见 PPT。&lt;/p>
&lt;h2 id="21-应用层基础概念">2.1 应用层基础概念
&lt;/h2>&lt;h3 id="应用层简述">应用层简述
&lt;/h3>&lt;p>应用层是作为程序员最常接触到的一层。在应用层，网络这个概念被抽象出来，你可以访问到达“Socket（套接字/该单词的原始含义为插座）”的数据流。由应用层来决定程序发送、接收到的数据的格式。
一般不同的应用会有不同的格式。&lt;/p>
&lt;h4 id="socket套接字">Socket（套接字👎）
&lt;/h4>&lt;p>进程通过其 Socket 发送/接受数据。
Socket 可近似为门，发送消息的进程将消息推到门外，由门外的传输基础设施将消息送达到接收进程。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311172209.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="寻址-addressing-过程">寻址 Addressing 过程
&lt;/h4>&lt;p>只依靠接收信息的计算机的 IP 地址不足以识别进程，因为一台主机上可以运行多个进程。为收到消息，进程也需要有标识符。标识符包括 IP 地址和该进程的端口号。
一些约定好的服务端口：HTTP 服务器 - 80， 邮件服务器 - 25。&lt;/p>
&lt;h4 id="应用层协议定义">应用层协议定义
&lt;/h4>&lt;ul>
&lt;li>
&lt;p>消息的类型：例如表示该消息为请求或响应。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息语法：消息中有哪些字段，都是怎样描述的。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>消息语义：字段的含义。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>规则：关于怎样处理消息的发送/响应。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>开放协议：在 RFC 中有定义，允许互相操作，例如 HTTP，SMTP 等。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>私有 Proprietary 协议：例如 Skype 等软件自己的协议。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="tcpip-的四种地址">TCP/IP 的四种地址
&lt;/h3>&lt;ul>
&lt;li>&lt;strong>第二层 - 物理地址/链路地址&lt;/strong>：由节点的 LAN 或 WAN 定义的地址&lt;/li>
&lt;li>&lt;strong>第三层 - 逻辑地址&lt;/strong>（32 位 IPv4，128 位 IPv6）：逻辑地址用于通用通信，不依赖底层物理网络&lt;/li>
&lt;li>&lt;strong>第四层 - 端口地址&lt;/strong>：用于区分不同的进程&lt;/li>
&lt;li>&lt;strong>第七层 - 应用规定的地址&lt;/strong>：有些应用会有用户友好型的地址，例如电子邮件地址。&lt;/li>
&lt;/ul>
&lt;h4 id="会话层与表示层">会话层与表示层
&lt;/h4>&lt;p>这课件排的稀碎，为什么在这又提一遍。。。&lt;/p>
&lt;ul>
&lt;li>会话层：关注两主机间连接的生命周期，身份验证与鉴权&lt;/li>
&lt;li>表示层：为应用“翻译”数据，例如确定用于编码的具体的字符集等。
这俩层在现实的互联网中都不存在，都在&lt;strong>应用层&lt;/strong>实现。&lt;/li>
&lt;/ul>
&lt;h2 id="31-传输层服务">3.1 传输层服务
&lt;/h2>&lt;h3 id="传输层服务与协议">传输层服务与协议
&lt;/h3>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原&lt;/th>
&lt;th>provide logical communication between app processes running on different hosts&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>译&lt;/td>
&lt;td>为在不同主机上运行的应用程序进程之间提供逻辑通信&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>传输层协议在终端系统上运行。&lt;/p>
&lt;ul>
&lt;li>发送端将应用层消息分成&lt;strong>段 Segments&lt;/strong>，传给网络层。&lt;/li>
&lt;li>接收端将段合成消息，传给应用层。
传输层对应用有不止一种协议，例如 TCP 和 UDP。&lt;/li>
&lt;/ul>
&lt;h3 id="传输层与网络层">传输层与网络层
&lt;/h3>&lt;ul>
&lt;li>网络层负责&lt;strong>主机间&lt;/strong>的逻辑通信&lt;/li>
&lt;li>传输层负责&lt;strong>进程间&lt;/strong>的逻辑通信（依赖于&amp;amp;增强了网络层的服务）&lt;/li>
&lt;/ul>
&lt;h2 id="32-多路复用-mux-与解复用-demux">3.2 多路复用 Mux 与解复用 Demux
&lt;/h2>&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原&lt;/th>
&lt;th>Combining several streams of data into a single stream&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>译&lt;/td>
&lt;td>将多个数据流合并为单个流&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>例如，刷手机的时候，一边看网页，一边看邮件，一边看微信，这些所有连接都通过同一条链路。&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>原&lt;/th>
&lt;th>A stream of data is separated out into its individual components&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>译&lt;/td>
&lt;td>多路复用的相反过程，将一个数据流拆分为其独立的组成&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>手机接收到的数据流被拆分，发送给合适的程序。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311185107.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="解复用是怎样工作的">解复用是怎样工作的
&lt;/h3>&lt;p>主机接收到 IP 数据报 Datagram 后：&lt;/p>
&lt;ul>
&lt;li>每个数据报都会有其来源 IP 地址和其目标 IP 地址&lt;/li>
&lt;li>每条数据报都会携带传输层的数据段&lt;/li>
&lt;li>传输层的数据段带有来源和目标端口号&lt;/li>
&lt;/ul>
&lt;p>主机即可根据 IP 地址与&lt;strong>端口号&lt;/strong>，将数据定位到合适的 Socket 中。&lt;/p>
&lt;h3 id="无连接的解复用过程udp">无连接的解复用过程（UDP）
&lt;/h3>&lt;p>回忆一下两个前提：&lt;/p>
&lt;ol>
&lt;li>创建的 Socket 拥有一个本地的端口号&lt;/li>
&lt;li>将数据报发送到 UDP Socket 时，必须指定目标 IP 地址和端口
主机接收到 UDP 数据段时：&lt;/li>
&lt;li>检查数据段中的目标端口&lt;/li>
&lt;li>将 UDP 数据段指向到该端口的 Socket
具有相同目标端口但来自不同 IP 地址的 IP 数据报会被指向到同一个 socket。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311204107.png"
loading="lazy"
>&lt;/li>
&lt;/ol>
&lt;h3 id="面向连接的解复用过程tcp">面向连接的解复用过程（TCP）
&lt;/h3>&lt;p>TCP socket 由四个元组指定：&lt;/p>
&lt;ol>
&lt;li>源 IP 地址&lt;/li>
&lt;li>源端口号&lt;/li>
&lt;li>目标 IP 地址&lt;/li>
&lt;li>目标端口号&lt;/li>
&lt;/ol>
&lt;p>服务器主机可以同时支持多个 TCP socket。每个 socket 都由其自己的四个元组指定。解复用时，接收端使用这四个值将数据段指向合适的 socket。
Web 服务器对每个连接的客户端都有不同的 socket。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240311205503.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="一些常用的端口号">一些常用的端口号
&lt;/h4>&lt;ul>
&lt;li>80：标准 HTTP 服务器&lt;/li>
&lt;li>22：从远程计算机登录 SSH&lt;/li>
&lt;li>25：SMTP，用来发邮件&lt;/li>
&lt;li>143：IMAP，用来收邮件&lt;/li>
&lt;li>443：HTTPS 服务器，安全标准的 HTTP
只是约定俗成，你愿意的话也可以自己改。&lt;/li>
&lt;/ul>
&lt;h2 id="33-无连接传输udp">3.3 无连接传输：UDP
&lt;/h2>&lt;p>UDP = User Datagram Protocol
是最简单的可用的互联网传输协议。“尽力而为”，UDP 数据段可能会丢失，可能到达应用层时是无序的。
&lt;strong>无连接（Connectionless）是指：&lt;/strong>&lt;/p>
&lt;ol>
&lt;li>在 UDP 发送端和接收端间无需握手，可以直接发送&lt;/li>
&lt;li>每个 UDP 包都独立于其他包处理&lt;/li>
&lt;/ol>
&lt;p>UDP 协议用于：&lt;/p>
&lt;ol>
&lt;li>直播等多媒体应用，其对丢包可容忍，对速率要求高。&lt;/li>
&lt;li>DNS（=Domain Name System）&lt;/li>
&lt;li>SNMP（=Simple Network Management Protocol）&lt;/li>
&lt;/ol>
&lt;p>若需要为 UDP 添加可靠性，则应在应用层添加可靠性处理和错误恢复等。&lt;/p>
&lt;h3 id="为什么选择-udp">为什么选择 UDP
&lt;/h3>&lt;ul>
&lt;li>不需要建立连接&lt;/li>
&lt;li>通信简单，在发送端、接收端没有连接状态&lt;/li>
&lt;li>表头大小更小&lt;/li>
&lt;li>没有拥塞控制，传播更快&lt;/li>
&lt;/ul>
&lt;h3 id="udp-消息段表头">UDP 消息段表头
&lt;/h3>&lt;p>来源端口、目标端口、消息段长度、&lt;strong>校验和（↓）&lt;/strong>&lt;/p>
&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312130356.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="udp-校验和">UDP 校验和
&lt;/h4>&lt;p>目标：侦测到传输的消息段中的传输错误（例如比特反转）&lt;/p>
&lt;p>发送端：将消息段（包含表头字段）视作 16 位整数，将字段内容相加，将计算得到的校验和放到 UDP 的校验和字段。
接收端：计算收到的消息段的校验和，检查计算得到的值与表头的值是否一致。如果不一致则出现了错误，如果一致则一般没有错误（可能侦测不到部分情况的错误）。&lt;/p>
&lt;h4 id="udp-消息头封装">UDP 消息头封装
&lt;/h4>&lt;p>&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312131254.png"
loading="lazy"
>&lt;/p>
&lt;h2 id="34-可靠消息传输rdt法则">3.4 可靠消息传输（rdt）法则
&lt;/h2>&lt;p>可靠消息传输向上层提供（抽象的）可靠消息传输服务，在不可靠信道上依赖 rdt 协议进行可靠传输。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312131635.png"
loading="lazy"
>&lt;/p>
&lt;h4 id="前置知识有限状态机">前置知识：有限状态机
&lt;/h4>&lt;p>课件里描述协议机制用的。&lt;strong>例 - 投币道闸：&lt;/strong>
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312132243.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="rdt-10---通过可靠信道进行可靠传输">rdt 1.0 - 通过可靠信道进行可靠传输
&lt;/h3>&lt;p>要求信道完全可靠，没有比特错误，也没有丢包。
将发送端和接收端分别拆成状态机：发送端打包消息然后发送，接收端等待接收消息然后解包。
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312132512.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="rdt-20---信道存在比特错误">rdt 2.0 - 信道存在比特错误
&lt;/h3>&lt;p>信道可能将数据包中的部分数据出现比特反转，校验和可以检测到此错误。
怎样从错误中恢复：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>ACK（acknowledgement）&lt;/strong>：接收端显式通知发送端，数据包成功接收&lt;/li>
&lt;li>&lt;strong>NAK（negative acknowledgements）&lt;/strong>：接收端显式通知发送端，数据包存在错误&lt;/li>
&lt;li>收到 NAK 后，发送端会重新传输数据包。
&lt;strong>rdt 2.0 中的新机制&lt;/strong>：错误检测，反馈（发送 ACK、NAK）
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312134610.png"
loading="lazy"
>&lt;/li>
&lt;/ul>
&lt;h4 id="rdt-20-的致命缺陷">rdt 2.0 的致命缺陷
&lt;/h4>&lt;p>&lt;strong>ACK/NAK 损坏&lt;/strong>：发送端不清楚接收端的情况，也不能直接重传，有可能会重复。
怎样处理重复？&lt;/p>
&lt;ul>
&lt;li>若 ACK 或 NAK 损坏，则重新传输。&lt;/li>
&lt;li>发送端对每个数据包添加序列号（seq），接收端将无视重复的数据包。
&lt;strong>发送端发出一个数据包后，会等待接收端的响应后再决定下一步的行为&lt;/strong>&lt;/li>
&lt;/ul>
&lt;h3 id="rdt-21---解决-20-的一些问题">rdt 2.1 - 解决 2.0 的一些问题
&lt;/h3>&lt;p>发送端为每个数据包添加两种序列号之一#(0, 1)，检查收到的 ACK/NAK 是否损坏。
接收端检查收到的数据包是否重复。
&lt;strong>发送端&lt;/strong>：
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312141737.png"
loading="lazy"
>
&lt;strong>接收端&lt;/strong>：
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312141755.png"
loading="lazy"
>&lt;/p>
&lt;h3 id="rdt-30---存在错误和丢包的信道">rdt 3.0 - 存在错误和丢包的信道
&lt;/h3>&lt;p>信道可能出现丢包。数据包和 ACK/NAK 都有可能丢失。
做法：发送端等待 ACK 一定时间，时间过后如果没有收到 ACK 就重发。
（如果数据包或 ACK 只是延迟而非超时丢包，重传会重复，但是序列号已经能处理此问题了）
&lt;img src="https://katomelon.github.io/blog/blog/p/ipn-w1/assets/Pasted%20image%2020240312143339.png"
loading="lazy"
>&lt;/p></description></item></channel></rss>