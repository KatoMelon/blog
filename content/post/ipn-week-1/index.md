---
title: 互联网协议 - Week1概念整理
description: 课程第一周PPT知识点整理，完成于03.12
slug: ipn-w1
date: 2024-08-08 00:00:00+0000
# image: cover.jpg
categories:
    - 课业
tags:
    - 互联网协议
---

![Page Views Count](https://badges.toozhao.com/badges/01HJ3GGQ6MR66VM70BVZS4SSVX/green.svg)

## 1.1 何为互联网

本部分定义/介绍了课程中需要使用的一些基本概念：互联网的组成、元素，何为协议，网络边缘与网络核心，一些基础术语（比特、字节、网络数据），何为物理媒介、何为带宽等等。

### 互联网的组成

#### 从构成的角度

互联网是连接计算机与计算机的网络（这门课的另外一个名字叫计算机网络），即数以百万计的相连计算机构成了互联网。

- **主机 Host**：即终端系统，运行着网络应用程序。
- **通信链路 Communication links**：即光纤 fiber、铜线 copper、无线电 radio、卫星 satellite 等用于传输信息的链路设备。
- **带宽 Bandwidth**：数据链路的传输速率。
- **数据包交换器 Packet switches**：用来转发 Forward 数据包，可以是路由器 Router 或交换机 switches。

此外：

- 互联网是“网中之网”，连接起多个**互联网服务提供商 ISP, Internet Service Provider**，能够互相通信。
- 数据的正常通信需要依靠事先约定好的**协议 Protocol** 才能进行。例如 TCP、IP、HTTP、802.11(WiFi 标准) 等等。
- 有多种多样的**互联网标准 Internet Standards**，如 RFC，IETF 等等。

![](Pasted%20image%2020240308142457.png)

#### 从服务的角度

- 向应用提供服务的基础设施
  Web, VoIP (Voice over IP), email, games, e-commerce, social nets 等。
- 向应用提供编程接口的基础设施
  允许发送和接收应用程序“连接”到互联网的钩子，提供服务选项，类似于邮政

### 何为协议 Protocol

| 原   | protocols define format, order of messages sent and received among network entities, and actions taken on message transmission, receipt |
| --- | --------------------------------------------------------------------------------------------------------------------------------------- |
| 译   | 协议定义了网络实体之间发送和接收消息的格式、顺序，以及消息发送、接收时所采取的动作                                                                                               |

![](Pasted%20image%2020240308151018.png)

## 1.2 网络边缘

### 网络边缘与网络核心

想象互相连接无数设备的互联网是一张大网，“网络边缘 Network Edge”即网络的终端设备（服务器 Server 与客户端 Client），通过“接入网 Access Network”与网络的其他部分相连，通过“核心网 Network Core”连接网中之网，互相通信。

- **网络边缘 Network Edge**：是用户和计算机与网络相连的部分，即主机 Hosts（服务器 + 客户端），服务器通常在数据中心里。
- **接入网 Access Network、物理媒介 Physical Media**：是将网络边缘与网络的其他部分相连的部分。例如家庭网，办公网，移动网络等等。
- **核心网 Network Core**：网络的“中心”部分，即互相连接的路由器，网中之网。

### 比特 Bit 和字节 Byte

- 一个比特 bit 即一个二进制数字 Binary Digit（0 或 1）
- 一个字节 Byte 为一组共 8 个比特，可视为 0-255（或 -128 到 127）的数字，或两位十六进制 Hexadecimal 数字（A0, FF, 10 这样的）

数据量（KB MB GB）通常以字节为单位，传输速度（Kb/s Mb/s）通常以比特作单位。
![](Pasted%20image%2020240308161151.png)

### 网络数据包 Packet

*数据包（packet），另译作报文/数据报文*
很大的数据难以传输，将数据切分成小单元（即数据包 Packets）会很有用。
数据包传输起来相对更快，可以检查传输错误，如果发现错误，可以重新传输。

#### 数据包传输过程

- 获取应用消息
- 将数据切分为长度为 L 个比特的数据包
- 将数据包以**传输速率 transmission rate**（表示为 R）传输进接入网

- **link transmission rate**, aka **link capacity**, aka **link bandwidth**
- 链路传输速率，又名链路容量，又名链路带宽

## 1.3 核心网 Network Core

#### 数据包的传输延迟 Delay

例：1500B 的数据以 1Mb/s 的速率传输，（传输延迟）耗时多少？
Time = 1500×8 (bits) / 1000000 (bits/s) = 0.012s = 12ms
![](Pasted%20image%2020240308163049.png)
核心网是内部相连的多个路由器构成的网格。在进行数据包交换时，主机会将应用层数据分解为数据包。从来源到目的地的链路上，将数据包由一个路由器上转发到另一个中。每个数据包都以全容量传输。数据包必须**完整到达**路由器后才可进行下一步的传输。

例：如图所示，传输**1500B**大小的数据包有多长时间的（传输）延迟？
![](Pasted%20image%2020240308203537.png)
Time = 1500×8 (bits) / 1000000 (bits/s) + 1500×8 (bits) / 2000000 (bits/s) = 18ms

#### 队列 Queue 与丢包 Loss

如果到达的数据包超过了链路的传输速率：
- 数据包将**进入排队**，等待传输。
- 如果缓冲区 Buffer**已满**，数据包将会**丢失**。

### 核心网的两大功能

- **路由 Routing**：决定数据包从来源到目的地的**路线 Route**。
- **转发 Forwarding**：将数据包从路由器的输入**移动到**合适的路由器出口。

### 互联网的结构

1. 每个使用者不可能直接连接（需要的连接数太多），所以每个使用者先连接到互联网服务提供商。
2. 互联网服务提供是一项可行的业务，所以会有多家 ISP 进行竞争。
3. 多个 ISP 间也需要互相连接（通过 Internet eXchange Provider），不然中国电信的用户就没法给中国移动的用户发微信了。
4. 可能出现区域网络用来连接接入网到 ISP。
5. 谷歌等大型企业则通过内容提供网络向用户提供服务。

![](Pasted%20image%2020240310152100.png)
一种结构：谷歌等大公司会直接将其数据中心连接到互联网，通常会绕过一级 ISP 和区域性 ISP。
![](Pasted%20image%2020240310152711.png)

## 1.4 延迟 Delay 丢包 Loss 吞吐量 Throughput

回顾 - 丢包和延迟是怎么产生的：[队列Queue与丢包Loss](互联网协议/互联网协议%20Part%20A.md#队列Queue与丢包Loss)

### 延迟的组成

d_total = d_proc + d_queue + d_trans + d_prop
![](Pasted%20image%2020240310153709.png)
- **d_proc**：该节点的**处理延迟**。用于校验比特错误，决定输出链路。通常花费小于毫秒的时间。
- **d_queue**：在输出链路上**排队等待传输的延迟**，取决于路由器的拥塞程度。
- **d_trans**：**传输延迟**。[数据包的传输延迟Delay](互联网协议/互联网协议%20Part%20A.md#数据包的传输延迟Delay) = L/R。可理解为路由器将比特写入到输出端的耗时。
- **d_prop**：**传播 Propagate 延迟**。为数据在介质中传播的时间，= 物理链路长度 d/传播速度 s
**传输延迟和传播延迟是两个不同的概念。**

### 丢包 Loss

队列（或称缓冲区 Buffer）容量有限，队列满后到达的数据包将丢失。
丢失的数据包可能由上个节点重传，可能由数据发送源重传，也可能就不传了。
![](Pasted%20image%2020240310154944.png)

### 吞吐量 Throughput

| 原   | throughput: rate (bits/time unit) at which bits transferred between sender/receiver |
| --- | ----------------------------------------------------------------------------------- |
| 译   | 吞吐量：发送端/接收端之间传输比特的速率 (比特/时间单位)                                                      |

分瞬时值和某段时间的平均值。
**瓶颈链路 Bottleneck Link**：限制端到端吞吐量的链路。
![](Pasted%20image%2020240311145352.png)
共用链路计算端到端吞吐量时应取平均到每条链路上的吞吐量计算瓶颈值。

## 1.5 协议层与服务模型

### 为什么需要分层

- 显式指定结构可明确复杂系统的各个部分（参考模型待下文讨论）。
- 模块化简化了系统的维护和更新步骤（某部分的实现的变更对系统的其他部分透明）。

### TCP/IP 模型（互联网模型）

TCP = 传输控制协议 Transmission Control Protocol
IP = 互联网协议 Internet Protocol
**自顶向下：应用层、传输层、网络层、链路层、物理层。**
- **应用层**：支持网络应用程序（FTP、SMTP、HTTP 等）
- **传输层**：进程之间的数据传输（TCP、UDP）
- **网络层**：数据报 Datagrams 从源到目的地的路由（IP、路由协议）
- **链路层**：临近网路单元间的数据传输（以太网 Ethernet、WiFi、PPP）
- **物理层**：即比特在线缆上的传输

![](Pasted%20image%2020240311151005.png)

### ISO/OSI 参考模型

ISO = 国际标准化组织 Internet Standards Office
OSI = 开放系统互连标准 Open System Interconnection
**相比互联网模型添加了表示层和会话层**
- **表示层**：允许应用解释数据含义，例如加密压缩等。
- **会话层**：提供数据同步、检查点、数据恢复交换等。
互联网模型缺少这两层，如有需要应当在**应用层**实现。
![](Pasted%20image%2020240311151240.png)
![](Pasted%20image%2020240311155907.png)

### 传输模型的各层

- **第七层 - 应用层**：计算机上的应用程序的数据。
- **第六层 - 表示层**：与字符集的设定和表示有关（在 TCP/IP 和现实互联网中不存在）
- **第五层 - 会话层**：与连接的整个生命周期有关（在 TCP/IP 和现实互联网中不存在）
- **第四层 - 传输层**：与机器间的端到端连接有关。包含有关稳定性的信息、有关机器上的哪个程序将会发送/接受此数据的信息。
- **第三层 - 网络层**：使得数据能够从出发的计算机到接受的计算机。带有计算机的 IP 地址，带有校验和 checksum 以检验数据是否受损。
- **第二层 - 数据链路层**：使得数据能够到达临近（在同一本地网络下）的计算机。包含 MAC（Media Access Control）地址以区分计算机。
- **第一层 - 物理层**：天上的无线电，地下的电缆。

### 各层的设备

 - **路由器**：第三层的设备。读取第三层的地址，决定数据包将往哪个方向走。
 - **交换机**：第二层的设备。读取第二层的地址，决定哪台临近的计算机应当得到该信息。交换机通常比路由器要简单。
 - **中继器**：第一层的设备。加强信号或重构受损的信号，使得能够继续发送他。

### TCP/IP：分层与表头

TCP/IP 模型的绝大多数层都伴随一个“表头”（“表头和表尾”）
**表头中包含与发送的信息相分离的信息，用以说明关于此信息的一些信息。**
（除物理层）每层都会附加一个 Header，例如网络层会附加一个网络地址表示该数据包将被发送到哪里，传输层会附加一个端口号表示要将该包发送给哪个程序。
下层状态会包含上层所有的包。例如第二层（链路层）中会包含来自第三层、第四层的包。
![](Pasted%20image%2020240311155600.png)

### 为什么有 ISO/OSI 和 TCP/IP 两种模型

**一句话说完**：ISO/OSI 模型是委员会提出的，很理想化，且规划模型花费了很长时间；TCP/IP 模型是工程师提出的，目标是能上线用起来再说，在实验中对该协议进行新的修改和应用。ISO/OSI 模型提出的时候，TCP/IP 已经发展的大到不可改变的程度了。
会话层和表示层很有用，但是现在还不存在。
![](Pasted%20image%2020240311161832.png)

## 1.6 发展历史

略，详见 PPT。

## 2.1 应用层基础概念

### 应用层简述

应用层是作为程序员最常接触到的一层。在应用层，网络这个概念被抽象出来，你可以访问到达“Socket（套接字/该单词的原始含义为插座）”的数据流。由应用层来决定程序发送、接收到的数据的格式。
一般不同的应用会有不同的格式。

#### Socket（套接字👎）

进程通过其 Socket 发送/接受数据。
Socket 可近似为门，发送消息的进程将消息推到门外，由门外的传输基础设施将消息送达到接收进程。
![](Pasted%20image%2020240311172209.png)

#### 寻址 Addressing 过程

只依靠接收信息的计算机的 IP 地址不足以识别进程，因为一台主机上可以运行多个进程。为收到消息，进程也需要有标识符。标识符包括 IP 地址和该进程的端口号。
一些约定好的服务端口：HTTP 服务器 - 80， 邮件服务器 - 25。

#### 应用层协议定义

- 消息的类型：例如表示该消息为请求或响应。
- 消息语法：消息中有哪些字段，都是怎样描述的。
- 消息语义：字段的含义。
- 规则：关于怎样处理消息的发送/响应。

- 开放协议：在 RFC 中有定义，允许互相操作，例如 HTTP，SMTP 等。
- 私有 Proprietary 协议：例如 Skype 等软件自己的协议。

### TCP/IP 的四种地址

- **第二层 - 物理地址/链路地址**：由节点的 LAN 或 WAN 定义的地址
- **第三层 - 逻辑地址**（32 位 IPv4，128 位 IPv6）：逻辑地址用于通用通信，不依赖底层物理网络
- **第四层 - 端口地址**：用于区分不同的进程
- **第七层 - 应用规定的地址**：有些应用会有用户友好型的地址，例如电子邮件地址。

#### 会话层与表示层

这课件排的稀碎，为什么在这又提一遍。。。
- 会话层：关注两主机间连接的生命周期，身份验证与鉴权
- 表示层：为应用“翻译”数据，例如确定用于编码的具体的字符集等。
这俩层在现实的互联网中都不存在，都在**应用层**实现。

## 3.1 传输层服务

### 传输层服务与协议

| 原   | provide logical communication between app processes running on different hosts |
| --- | ------------------------------------------------------------------------------ |
| 译   | 为在不同主机上运行的应用程序进程之间提供逻辑通信                                                       |

传输层协议在终端系统上运行。
- 发送端将应用层消息分成**段 Segments**，传给网络层。
- 接收端将段合成消息，传给应用层。
传输层对应用有不止一种协议，例如 TCP 和 UDP。

### 传输层与网络层

- 网络层负责**主机间**的逻辑通信
- 传输层负责**进程间**的逻辑通信（依赖于&增强了网络层的服务）

## 3.2 多路复用 Mux 与解复用 Demux

| 原   | Combining several streams of data into a single stream |
| --- | ------------------------------------------------------ |
| 译   | 将多个数据流合并为单个流                                           |

例如，刷手机的时候，一边看网页，一边看邮件，一边看微信，这些所有连接都通过同一条链路。

| 原   | A stream of data is separated out into its individual components |
| --- | ---------------------------------------------------------------- |
| 译   | 多路复用的相反过程，将一个数据流拆分为其独立的组成                                        |

手机接收到的数据流被拆分，发送给合适的程序。
![](Pasted%20image%2020240311185107.png)

### 解复用是怎样工作的

主机接收到 IP 数据报 Datagram 后：
- 每个数据报都会有其来源 IP 地址和其目标 IP 地址
- 每条数据报都会携带传输层的数据段
- 传输层的数据段带有来源和目标端口号

主机即可根据 IP 地址与**端口号**，将数据定位到合适的 Socket 中。

### 无连接的解复用过程（UDP）

回忆一下两个前提：
 1. 创建的 Socket 拥有一个本地的端口号
 2. 将数据报发送到 UDP Socket 时，必须指定目标 IP 地址和端口
主机接收到 UDP 数据段时：
1. 检查数据段中的目标端口
2. 将 UDP 数据段指向到该端口的 Socket
具有相同目标端口但来自不同 IP 地址的 IP 数据报会被指向到同一个 socket。
![](Pasted%20image%2020240311204107.png)

### 面向连接的解复用过程（TCP）

TCP socket 由四个元组指定：
1. 源 IP 地址
2. 源端口号
3. 目标 IP 地址
4. 目标端口号

服务器主机可以同时支持多个 TCP socket。每个 socket 都由其自己的四个元组指定。解复用时，接收端使用这四个值将数据段指向合适的 socket。
Web 服务器对每个连接的客户端都有不同的 socket。
![](Pasted%20image%2020240311205503.png)

#### 一些常用的端口号

- 80：标准 HTTP 服务器
- 22：从远程计算机登录 SSH
- 25：SMTP，用来发邮件
- 143：IMAP，用来收邮件
- 443：HTTPS 服务器，安全标准的 HTTP
只是约定俗成，你愿意的话也可以自己改。

## 3.3 无连接传输：UDP

UDP = User Datagram Protocol
是最简单的可用的互联网传输协议。“尽力而为”，UDP 数据段可能会丢失，可能到达应用层时是无序的。
**无连接（Connectionless）是指：**
1. 在 UDP 发送端和接收端间无需握手，可以直接发送
2. 每个 UDP 包都独立于其他包处理

UDP 协议用于：
1. 直播等多媒体应用，其对丢包可容忍，对速率要求高。
2. DNS（=Domain Name System）
3. SNMP（=Simple Network Management Protocol）

若需要为 UDP 添加可靠性，则应在应用层添加可靠性处理和错误恢复等。

### 为什么选择 UDP

- 不需要建立连接
- 通信简单，在发送端、接收端没有连接状态
- 表头大小更小
- 没有拥塞控制，传播更快

### UDP 消息段表头

来源端口、目标端口、消息段长度、**校验和（↓）**

![](Pasted%20image%2020240312130356.png)

#### UDP 校验和

目标：侦测到传输的消息段中的传输错误（例如比特反转）

发送端：将消息段（包含表头字段）视作 16 位整数，将字段内容相加，将计算得到的校验和放到 UDP 的校验和字段。
接收端：计算收到的消息段的校验和，检查计算得到的值与表头的值是否一致。如果不一致则出现了错误，如果一致则一般没有错误（可能侦测不到部分情况的错误）。

#### UDP 消息头封装

![](Pasted%20image%2020240312131254.png)

## 3.4 可靠消息传输（rdt）法则

可靠消息传输向上层提供（抽象的）可靠消息传输服务，在不可靠信道上依赖 rdt 协议进行可靠传输。
![](Pasted%20image%2020240312131635.png)

#### 前置知识：有限状态机

课件里描述协议机制用的。**例 - 投币道闸：**
![](Pasted%20image%2020240312132243.png)

### rdt 1.0 - 通过可靠信道进行可靠传输

要求信道完全可靠，没有比特错误，也没有丢包。
将发送端和接收端分别拆成状态机：发送端打包消息然后发送，接收端等待接收消息然后解包。
![](Pasted%20image%2020240312132512.png)

### rdt 2.0 - 信道存在比特错误

信道可能将数据包中的部分数据出现比特反转，校验和可以检测到此错误。
怎样从错误中恢复：
- **ACK（acknowledgement）**：接收端显式通知发送端，数据包成功接收
- **NAK（negative acknowledgements）**：接收端显式通知发送端，数据包存在错误
- 收到 NAK 后，发送端会重新传输数据包。
**rdt 2.0 中的新机制**：错误检测，反馈（发送 ACK、NAK）
![](Pasted%20image%2020240312134610.png)

#### rdt 2.0 的致命缺陷

**ACK/NAK 损坏**：发送端不清楚接收端的情况，也不能直接重传，有可能会重复。
怎样处理重复？
- 若 ACK 或 NAK 损坏，则重新传输。
- 发送端对每个数据包添加序列号（seq），接收端将无视重复的数据包。
**发送端发出一个数据包后，会等待接收端的响应后再决定下一步的行为**

### rdt 2.1 - 解决 2.0 的一些问题

发送端为每个数据包添加两种序列号之一#(0, 1)，检查收到的 ACK/NAK 是否损坏。
接收端检查收到的数据包是否重复。
**发送端**：
![](Pasted%20image%2020240312141737.png)
**接收端**：
![](Pasted%20image%2020240312141755.png)

### rdt 3.0 - 存在错误和丢包的信道

信道可能出现丢包。数据包和 ACK/NAK 都有可能丢失。
做法：发送端等待 ACK 一定时间，时间过后如果没有收到 ACK 就重发。
（如果数据包或 ACK 只是延迟而非超时丢包，重传会重复，但是序列号已经能处理此问题了）
![](Pasted%20image%2020240312143339.png)
